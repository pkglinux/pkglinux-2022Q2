.\" generated with Ronn-NG/v0.9.1
.\" http://github.com/apjanke/ronn-ng/tree/0.9.1
.TH "DWARFS\-FORMAT" "5" "June 2022" ""
.SH "NAME"
\fBdwarfs\-format\fR \- DwarFS File System Format v2\.3
.SH "DESCRIPTION"
This document describes the DwarFS file system format, version 2\.3\.
.SH "FILE STRUCTURE"
A DwarFS file system image is just a sequence of blocks\. Each block has the following format:
.IP "" 4
.nf
     ┌───┬───┬───┬───┬───┬───┬───┬───┐
0x00 │'D'│'W'│'A'│'R'│'F'│'S'│MAJ│MIN│  MAJ=0x02, MIN=0x03 for v2\.3
     ├───┴───┴───┴───┴───┴───┴───┴───┤
0x08 │                               │  Used for full (slow) integrity
     ├─ SHA\-512/256 integrity hash  ─┤  check with `dwarfsck`\.
0x10 │  over the remainder of the    │
     ├─ block data, starting at     ─┤
0x18 │  offset 0x28\.                 │
     ├─                             ─┤
0x20 │                               │
     ├───────────────────────────────┤
0x28 │  XXH3\-64 hash over remainder  │  Used for fast integrity check\.
     ├───────────────┬───────┬───────┤
0x30 │Section Number │SecType│CompAlg│  All integer fields are in LE
     ├───────────────┴───────┴───────┤  byte order\.
0x38 │   Length of remaining data    │
     ├───────────────────────────────┤
0x40 │                               │
     │ Section data compressed using │
     │ CompAlg algorithm\.            │
     │                               │
     │                               │
     │                               │
     └───────────────────────────────┘
.fi
.IP "" 0
.P
A couple of notes:
.IP "\[ci]" 4
No padding is added between blocks\.
.IP "\[ci]" 4
The list of blocks can easily be traversed by using the length field to skip to the start of the next section\.
.IP "\[ci]" 4
Corruption can easily be detected using the XXH3\-64 hash\. Computation of this hash is so fast that it is in fact checked every single time a file system block is loaded\.
.IP "\[ci]" 4
Integrity can furthermore be checked using the SHA\-512/256 hash\. This is much slower, but should rarely be needed\.
.IP "\[ci]" 4
All header fields, except for the magic and version number, are protected by the hashes\.
.IP "\[ci]" 4
In case of corruption, sections can easily be retrieved by scanning for the magic\. The version number can be recovered by looking at all sections and choosing the majority\. The explicit section number helps to recover data if multiple sections are missing\.
.IP "\[ci]" 4
A major version number change will render the format incompatible\.
.IP "\[ci]" 4
A minor version number change will be backwards compatible, i\.e\. an old program will refuse to read a file system with a minor version larger than the one it supports\. However, a new program will still read all file systems with a smaller minor version number\.
.IP "" 0
.SS "Section Types"
There are currently 3 different section types\.
.TP
\fBBLOCK\fR (0)
A block of data\. This is where all file data is stored\. There can be an arbitrary number of blocks of this type\.
.TP
\fBMETADATA_V2_SCHEMA\fR (7)
The schema used to layout the \fBMETADATA_V2\fR block contents\. This is stored in "compact" thrift encoding\.
.TP
\fBMETADATA_V2\fR (8)
This section contains the bulk of the metadata\. It's essentially just a collection of bit\-packed arrays and structures\. The exact layout of each list and structure depends on the actual data and is stored separately in \fBMETADATA_V2_SCHEMA\fR\.
.SH "METADATA FORMAT"
Here is a high\-level overview of how all the bits and pieces relate to each other:
.IP "" 4
.nf
═════════════           ┌─────────────────────────────────────────────────────────────────────────┐
 DwarFS v2\.3            │                                                                         │
═════════════           │         ┌───────────────────────────────────────────┐                   │
                        │         │                                           │                   │
          dir_entries[] ▼         │              inodes[]                     │   directories[]   │
╔════╗   ┌────────────────┐       │  S_IFDIR ──►┌───────────────────┐         │  ┌────────────────┴─┐
║root╟──►│ name_index:  0 │       │             │ mode_index:     0 ├──────┐  └─►│ parent_entry:  0 │
╚════╝   │ inode_num:   0 ├───────┴────────────►│ owner_index:    0 │      │     │ first_entry:   1 │
         ├────────────────┤                     │ group_index:    0 │      │     ├──────────────────┤
     ┌───┤ name_index:  2 │                     │ atime_offset:   0 │      │     │ parent_entry:  0 │
┌────┼───┤ inode_num:   5 ├───────┐             │ mtime_offset: 417 │      │     │ first_entry:  11 │
│    │   ├────────────────┤       │             │ ctime_offset:   0 │      │     ├──────────────────┤
│ ┌──┼───┤ name_index:  3 │       │             ├───────────────────┤      │     │ parent_entry:  5 │
│ │  │   │ inode_num:   9 ├────┐  │             │        \|\.\|\.\|\.        │      │     │ first_entry:  12 │
│ │  │   ├────────────────┤    │  │  S_IFLNK ──►├───────────────────┤      │     ├──────────────────┤
│ │  │   │                │    │  │             │ mode_index:     2 │      │     │                  │
│ │  │   │      \|\.\|\.\|\.       │    │  └────────────►│ owner_index:    2 │      │     │       \|\.\|\.\|\.        │
│ │  │   │                │    │                │ group_index:    0 │      │     │                  │
│ │  │   └────────────────┘    │                │ atime_offset:   0 │      │     └──────────────────┘
│ │  │                         │                │ mtime_offset: 298 │      │
│ │  │                         │                │ ctime_offset:   0 │      │
│ │  │    names[]              │                ├───────────────────┤      │      modes[]
│ │  │   ┌────────────┐        │                │        \|\.\|\.\|\.        │      │     ┌─────────────┐
│ │  │   │ "usr"      │        │     S_IFREG ──►├───────────────────┤      └────►│   0040775   │
│ │  │   ├────────────┤        │     (unique)   │ mode_index:     1 │            ├─────────────┤
│ │  │   │ "share"    │        ├───────────────►│ owner_index:    0 ├──────┐     │   0100644   │
│ │  │   ├────────────┤        │                │ group_index:    0 │      │     ├─────────────┤
│ │  └──►│ "words"    │        │                │ atime_offset:   0 │      │     │     \|\.\|\.\|\.     │
│ │      ├────────────┤        │                │ mtime_offset: 298 │      │     └─────────────┘
│ └─────►│ "lib"      │        │                │ ctime_offset:   0 │      │
│        ├────────────┤        │                ├───────────────────┤      │      uids[]
│        │ "ls"       │        │                │        \|\.\|\.\|\.        │      │     ┌─────────────┐
│        ├────────────┤        │     S_IFREG ──►├───────────────────┤      └────►│       0     │
│        │    \|\.\|\.\|\.     │        │  ┌──(shared)   │ mode_index:     4 │            ├─────────────┤
▼        └────────────┘        │  │             │ owner_index:    2 │            │    1000     │
(inode\-off)                    │  │             │ group_index:    1 ├──────┐     ├─────────────┤
│                              │  │             │ atime_offset:   0 │      │     │     \|\.\|\.\|\.     │
│         symlink_table[]      │  │             │ mtime_offset: 298 │      │     └─────────────┘
│        ┌────────────┐        │  │             │ ctime_offset:   0 │      │
│        │      1     ├───┐    │  │             ├───────────────────┤      │      gids[]
│        ├────────────┤   │    │  │             │        \|\.\|\.\|\.        │      │     ┌─────────────┐
└───────►│      0     │   │    │  │  S_IFBLK ──►├───────────────────┤      │     │       0     │
         ├────────────┤   │    │  │  S_IFCHR    │                   │      │     ├─────────────┤
         │    \|\.\|\.\|\.     │   │  ┌─┼──┼─────────────┤        \|\.\|\.\|\.        │      └────►│     100     │
         └────────────┘   │  │ │  │             │                   │            ├─────────────┤
                          │  │ │  │ S_IFSOCK ──►├───────────────────┤            │     \|\.\|\.\|\.     │
                          │  │ │  │  S_IFIFO    │                   │            └─────────────┘
          symlinks[]      │  │ │  │             │        \|\.\|\.\|\.        │
         ┌────────────┐   │  │ │  │             │                   │
         │ "\.\./foo"   │   │  │ │  │             └───────────────────┘                 chunks[]
         ├────────────┤   │  │ │  │                                                  ┌──────────────┐
         │ "foo/bar"  │◄──┘  │ │  │                                            ┌────►│ block:     0 │
         ├────────────┤      │ └──┼──────────►(inode\-off)                      │     │ offset: 1698 │
         │    \|\.\|\.\|\.     │      │    │                │            chunk_table[]  │     │ size:   1012 │
         └────────────┘      ▼    ▼                │           ┌─────────────┐ │     ├──────────────┤
                   (inode\-off)    (inode\-off)      └──────────►│      0      ├─┘ ┌──►│ block:     0 │
                             │    │                            ├─────────────┤   │   │ offset: 1604 │
          devices[]          │    │      shared_files_table[]  │      1      ├───┘   │ size:     94 │
         ┌────────────┐      │    │     ┌───────────┐          ├─────────────┤       ├──────────────┤
         │   0x0107   │      │    └────►│     0     ├───┬─────►│      2      ├───┬──►│ block:     0 │
         ├────────────┤      │          ├───────────┤   │      ├─────────────┤   │   │ offset:    0 │
         │   0x0502   │◄─────┘          │     0     ├───┘      │      2      ├───┘   │ size:   1517 │
         ├────────────┤                 ├───────────┤          ├─────────────┤       ├──────────────┤
         │    \|\.\|\.\|\.     │                 │    \|\.\|\.\|\.    │          │     \|\.\|\.\|\.     │       │     \|\.\|\.\|\.      │
         └────────────┘                 └───────────┘          └─────────────┘       └──────────────┘
.fi
.IP "" 0
.P
Thanks to the bit\-packing, fields that are unused or only contain a single (zero) value, e\.g\. a \fBgroup_index\fR that's always zero because all files belong to the same group, do not occupy any space in the metadata block\.
.SS "Determining Inode Offsets"
Before you can start traversing the metadata, you need to determine the offsets for symlinks, regular files, devices etc\. in the \fBinodes\fR list\. The index into this list is the \fBinode_num\fR from \fBdir_entries\fR, but you can perform direct lookups based on the inode number as well\. The \fBinodes\fR list is strictly in the following order:
.IP "\[ci]" 4
directory inodes (\fBS_IFDIR\fR)
.IP "\[ci]" 4
symlink inodes (\fBS_IFLNK\fR)
.IP "\[ci]" 4
regular \fIunique\fR file inodes (\fBS_IREG\fR)
.IP "\[ci]" 4
regular \fIshared\fR file inodes (\fBS_IREG\fR)
.IP "\[ci]" 4
character/block device inodes (\fBS_IFCHR\fR, \fBS_IFBLK\fR)
.IP "\[ci]" 4
socket/pipe inodes (\fBS_IFSOCK\fR, \fBS_IFIFO\fR)
.IP "" 0
.P
The offsets can thus be found by using a binary search with a predicate on the inode more\. The shared file offset can be found by subtracting the length of \fBshared_files_table\fR from the total number of regular files\.
.SS "Unique and Shared File Inodes"
The difference between \fIunique\fR and \fIshared\fR file inodes is that there is only one \fIunique\fR file inode that references a particular index in the \fBchunk_table\fR, whereas there are multiple \fIshared\fR file inodes that will reference the same index\. This is how DwarFS implements file\-level de\-duplication beyond hardlinks\. Hardlinks share the same inode\. Duplicate files that are not hardlinked each have a unique inode, but still reference the same content through the \fBchunk_table\fR\.
.P
The \fBshared_files_table\fR provides the necessary indirection that maps a \fIshared\fR file inode to a \fBchunk_table\fR index\.
.SS "Traversing the Metadata"
You typically start at the root directory which is at \fBdir_entries[0]\fR, \fBinodes[0]\fR and \fBdirectories[0]\fR\. Note that the root directory implicitly has no name, so that \fBdir_entries[0]\.name_index\fR should not be used\.
.P
To determine the contents of a directory, we determine the range of entries from \fBdirectories[inode_num]\.first_entry\fR to \fBdirectories[inode_num + 1]\.first_entry\fR\. If both values are equal, the directory is empty\. Otherwise, we can look up the entries in \fBdir_entries[]\fR\.
.P
So for directory inodes, you can directly index into \fBdirectories\fR using the inode number\.
.P
For link inodes, you can index into \fBsymlink_table\fR, but you have to adjust the index for the link inode offset determined before:
.IP "" 4
.nf
link_index = symlink_table[inode_num \- link_inode_offset]
.fi
.IP "" 0
.P
With that, you can look up the contents of the symlink:
.IP "" 4
.nf
contents = symlinks[link_index]
.fi
.IP "" 0
.P
For \fIunique\fR regular file inodes, you can index into \fBchunk_table\fR after adjusting the index:
.IP "" 4
.nf
chunk_index = inode_num \- file_inode_offset
.fi
.IP "" 0
.P
For \fIshared\fR regular file inodes, you can index into the (unpacked) \fBshared_files_table\fR:
.IP "" 4
.nf
shared_index = shared_files[inode_num \- file_inode_offset \- num_unique_files]
.fi
.IP "" 0
.P
Then, you can index into \fBchunk_table\fR, but you need to adjust the index once more:
.IP "" 4
.nf
chunk_index = shared_index + num_unique_files
.fi
.IP "" 0
.P
The range of chunks that make up a regular file inode is \fBchunk_table[chunk_index]\fR to \fBchunk_table[chunk_index + 1]\fR\. If these values are equal, the file is empty\. Otherwise, you need to look up the range of chunks in \fBchunks\fR\.
.P
Each chunk references a range of bytes in one file system \fBBLOCK\fR\. These need to be concatenated to produce the file contents\.
.P
Both \fBchunk_table\fR and \fBdirectories\fR have a sentinel entry at the end to make sure you can perform range lookups for all indices\.
.P
Last but not least, to read the device id for a device inode, you can index into \fBdevices\fR:
.IP "" 4
.nf
device_id = devices[inode_num \- device_inode_offset]
.fi
.IP "" 0
.SH "OPTIONALLY PACKED STRUCTURES"
The overview above assumes metadata without any additional packing, which can be produced using:
.IP "" 4
.nf
mkdwarfs \-\-pack\-metadata=none,plain
.fi
.IP "" 0
.P
However, this isn't the default, and parts of the metadata are likely stored in a packed format\. These are mostly easy to unpack\.
.SS "Shared Files Table Packing"
The \fBshared_files_table\fR can be stored in a packed format that only encodes the number of shared links to a \fBchunk_table\fR index\. As the minimum number of links is always 2 (otherwise it wouldn't be shared), the numbers in the packed format are additionally offset by 2\. So for example, a packed table like
.IP "" 4
.nf
[0, 3, 1, 0, 1]
.fi
.IP "" 0
.P
would unpack to:
.IP "" 4
.nf
[0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 4]
.fi
.IP "" 0
.P
The packed format is used when \fBoptions\.packed_shared_files_table\fR is true\.
.SS "Directories Packing"
The \fBdirectories\fR table, when stored in packed format, omits all \fBparent_entry\fR fields and uses delta compression for the \fBfirst_entry\fR fields\.
.P
In order to unpack all information, you first have to delta\- decompress the \fBfirst_entry\fR fields, then traverse the whole directory tree once to fill in the \fBparent_entry\fR fields\. This sounds like a lot of work, but it's actually reasonably fast\. For example, for a file system with 15 million entries in 90,000 directories, reconstructing the \fBdirectories\fR takes only about 50 milliseconds\.
.P
The packed format is used when \fBoptions\.packed_directories\fR is true\.
.SS "Chunk Table Packing"
The \fBchunk_table\fR can also be stored delta\-compressed and must be unpacked accordingly\.
.P
The packed format is used when \fBoptions\.packed_chunk_table\fR is true\.
.SS "Names and Symlinks String Table Packing"
Both the \fBnames\fR and \fBsymlinks\fR tables can be stored in a packed format in \fBcompact_names\fR and \fBcompact_symlinks\fR\.
.P
There are two separate packing schemes that can be combined\. If none of these schemes is active, the difference between e\.g\. \fBnames\fR and \fBcompact_names\fR is that the former is stored as a "proper" list, whereas the latter is stored as a single string plus an index of offsets\. As lists of strings store both offset and length for each element, this already saves the storage for the length fields, which can easily be determined from the offsets at run\-time\.
.P
If the \fBpacked_index\fR scheme is used in addition, the index is stored delta\-compressed\.
.P
Last but not least, the individual strings can be compressed as well\. The fsst library \fIhttps://github\.com/cwida/fsst\fR allows for compression of short strings with random access and is typically able to reduce the overall size of the string tables by 50%, using a dictionary that is only a few hundred bytes long\. If a \fBsymtab\fR is set for the string table, this compression is used\.
.SH "AUTHOR"
Written by Marcus Holland\-Moritz\.
.SH "COPYRIGHT"
Copyright (C) Marcus Holland\-Moritz\.
.SH "SEE ALSO"
mkdwarfs(1), dwarfs(1), dwarfsextract(1), dwarfsck(1)
